# Big O notation არის გზა, რომ ავხსნათ რამდენად ნელდება ან ჩქარდება ალგორითმი
# მონაცემების რაოდენობის ზრდასთან ერთად.
# ის არ ითვლის ზუსტ დროს, არამედ აჩვენებს ზრდის ტენდენციას.
# Big O გვეხმარება ალგორითმების ერთმანეთთან შედარებაში ეფექტურობის მიხედვით.
# ყურადღება ექცევა ყველაზე ცუდ შემთხვევას (worst case).


# O(1) — მუდმივი დროის სირთულე
# ალგორითმის შესრულების დრო არ იცვლება მონაცემების რაოდენობის გაზრდისას.

# O(log n) — ლოგარითმული დროის სირთულე
# ყოველი ნაბიჯით მონაცემების რაოდენობა მნიშვნელოვნად მცირდება,
# ამიტომ ზრდა ძალიან ნელია.

# O(n) — ხაზოვანი დროის სირთულე
# შესრულების დრო იზრდება პირდაპირ პროპორციულად მონაცემების რაოდენობასთან.

# O(n log n) — ხაზოვანი-ლოგარითმული დროის სირთულე
# შედგება ხაზოვანი და ლოგარითმული ნაწილისგან,
# ხშირად ჩნდება ეფექტურ ალგორითმებში.

# O(n²) — კვადრატული დროის სირთულე
# მონაცემების რაოდენობის გაზრდისას დრო ძალიან სწრაფად იზრდება,
# ჩვეულებრივ ჩნდება ჩადგმული (nested) ლოგიკის დროს.


# Big O notation გვიჩვენებს, როგორ იცვლება ალგორითმის შესრულების დრო
# მაშინ, როცა მონაცემების რაოდენობა (n) იზრდება.
# იგი არ ზომავს ზუსტ დროს, არამედ ზრდის ტენდენციას.

# O(1) — მუდმივი დრო
# დრო არ იცვლება, რამდენიც არ უნდა გაიზარდოს მონაცემები.
# რეალური მაგალითი: წიგნის თაროზე კონკრეტული წიგნის აღება,
# როცა ზუსტად იცი რომელ ადგილას დევს.

# O(log n) — ლოგარითმული დრო
# ყოველი ნაბიჯით მონაცემების დიდი ნაწილი იშლება.
# რეალური მაგალითი: ტელეფონის კონტაქტებში სახელის ძებნა
# ან წიგნში სიტყვის პოვნა ანბანური საძიებლით.

# O(n) — ხაზოვანი დრო
# დრო იზრდება პირდაპირ მონაცემების რაოდენობის შესაბამისად.
# რეალური მაგალითი: კლასში ყველა მოსწავლის სახელის გადამოწმება
# ერთის შემდეგ მეორეს.

# O(n log n) — ხაზოვანი ლოგარითმული დრო
# შედარებით სწრაფია დიდ მონაცემებზე, მაგრამ მაინც საჭიროებს დამუშავებას.
# რეალური მაგალითი: ბარათების დალაგება წესიერად,
# როცა მუდმივად ყოფ შუაზე და ალაგებ ნაწილებად.

# O(n²) — კვადრატული დრო
# მონაცემების ზრდასთან ერთად დრო ძალიან სწრაფად იზრდება.
# რეალური მაგალითი: კლასში ყველა მოსწავლის შედარება ყველა დანარჩენთან,
# მაგალითად, ვის ვის იცნობს.


def get_first_element(arr):
    return arr[0]
# Big O --> O(1)


def sum_of_elements(arr):
    total = 0
    for num in arr:
        total += num
    return total
# Big O --> O(n)


def contains_number(lst, target):
    for num in lst:
        if num == target:
            return True
    return False
# Big O --> O(n)


def print_all_pairs(lst):
    for i in lst:
        for j in lst:
            print(i, j)
# Big O --> O(n^2)


def binary_search(lst, target):
    left = 0
    right = len(lst) - 1
    while left <= right:
        mid = (left + right) // 2
        if lst[mid] == target:
            return True
        elif lst[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return False
# Big O --> O(log n)


def linear_search(lst, target):
    for num in lst:
        if num == target:
            return True
    return False

def binary_search(lst, target):
    left = 0
    right = len(lst) - 1
    while left <= right:
        mid = (left + right) // 2
        if lst[mid] == target:
            return True
        elif lst[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return False

# Linear Search: O(n) → უნდა გაიაროს მთელი სია
# Binary Search: O(log n) → ნაბიჯი ყოველ ჯერზე სიის ნახევრდება
# დიდი სიებისთვის Binary Search ბევრად სწრაფია Linear Search-ზე